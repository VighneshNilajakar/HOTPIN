Architectural Feasibility and Firmware Blueprint for the HotPin ESP32-CAM Voice/Vision System




I. System Overview and Hardware Validation


The HotPin architecture aims to create a highly integrated device using the pin-constrained ESP32-CAM AI-Thinker module to switch dynamically between high-bandwidth video streaming (Camera/Standby Mode) and full-duplex voice interaction (Voice Interaction Mode). Achieving this requires meticulous planning regarding pin multiplexing, resource allocation, and robust driver management.


A. Review of Required Functionality and Operational Modes


The core functionality necessitates seamless, real-time context switching between two demanding modes.
The Camera/Standby Mode prioritizes visual data capture. The OV2640 camera streams high-resolution video frames, typically utilizing the ESP32’s I2S peripheral block configured in Camera Slave Receiving (parallel) mode.1 This requires sustained high-speed DMA access and large memory buffers. During this mode, the system maintains its network connection to stream visuals to the WebServer.
The Voice Interaction Mode requires low-latency, full-duplex audio processing for Speech-to-Text (STT) and Text-to-Speech (TTS). This involves configuring the I2S peripheral(s) for standard serial I2S TX/RX operation, handling audio input from the INMP441 microphone and output to the MAX98357A amplifier.3 This mode is critically dependent on real-time buffering and prioritized task execution to prevent audio artifacts. Importantly, due to the hardware conflict involving the I2S peripheral, the camera function must be fully suspended during this time.


B. ESP32-CAM AI-Thinker Pin Allocation Review and Constraints


The ESP32-CAM module, especially the AI-Thinker variant, presents significant limitations on available general-purpose input/output (GPIO) pins. The OV2640 camera consumes approximately 12 fixed pins for data, clock, and control signals (D0-D7, PCLK, HSYNC, VSYNC, XCLK, PWDN, RESET, SCCB SCL, SDA). These camera pin allocations are considered fixed and non-negotiable within the camera framework.
A primary architectural challenge stems from the onboard MicroSD card interface, which internally connects to several key GPIOs: GPIO 14 (CLK), GPIO 15 (CMD), GPIO 2 (Data 0), GPIO 4 (Data 1), GPIO 12 (Data 2), and GPIO 13 (Data 3).5 For the HotPin system, which relies on network streaming rather than local recording, these pins are essential for I2S audio operation. Therefore, a foundational constraint of the system architecture is the mandatory
disabling of all SD card functionality within the ESP-IDF menuconfig and firmware. This action frees up GPIOs 2, 4, 12, 13, 14, and 15 for use by the audio peripherals and user input.5


C. Detailed Hardware Interface Validation


The design requires three main external peripherals:
1. INMP441 (I2S Microphone): Requires Bit Clock (BCLK), Word Select (WS or LRCK), and Data In (DIN). This operates as an I2S Slave device, synchronized by the ESP32 acting as the I2S Master.3
2. MAX98357A (I2S Amplifier): Requires BCLK, WS, and Data Out (DOUT). This also operates as an I2S Slave device, controlled by the ESP32 Master.
3. Push Button: Connected to GPIO 4, intended for user interaction and mode switching. This requires a robust interrupt-driven approach with software debouncing and Finite State Machine (FSM) logic.7


D. Pin Conflict Analysis and Resolution


The utilization of specific GPIOs requires careful conflict mitigation, especially for GPIO 4.


1. Resolution for GPIO 4 (Button vs. Flash LED vs. SD Card Data)


GPIO 4 is central to the design, serving as the user input mechanism. However, on the AI-Thinker module, this pin is internally connected to the onboard Flash LED via a transistor (Q1) and is also linked to SD Card Data 1.5
The resolution strategy mandates two phases. First, the SD Card component must be disabled entirely in the build configuration to release GPIO 4 (and 2, 12, 13, 14, 15).5 Second, the Flash LED functionality must be actively managed in the firmware. Because GPIO 4 is used as an input for the button, it must be ensured that the internal LED remains off, regardless of pin state changes. The required procedure is to explicitly configure GPIO 4 as an output and drive it LOW immediately upon boot.10 Furthermore, to prevent unexpected illumination or flickering caused by transient initialization states during boot sequences, particularly those related to the camera driver or Wi-Fi stack initialization 12, the function
rtc_gpio_hold_en(GPIO_NUM_4) must be called early in the system startup to maintain the LOW state across potential resets or power state changes.11 This proactive control minimizes visual artifacts and ensures a clean input signal for the button FSM.


2. Selection of Dedicated I2S Audio Pins (RX and TX)


To ensure stable, full-duplex audio operation separate from the camera interface, the design uses two distinct I2S controllers: I2S0 for the Transmit (TX) function and I2S1 for the Receive (RX) function. The ESP32 permits sharing the clock signals (BCLK and WS) between these two controllers, provided the configuration is identical, which is necessary for combined operation.3 This configuration utilizes the GPIOs freed by disabling the SD card interface.
Table 1 details the final, validated pin assignment for the HotPin architecture.
Table 1: HotPin Architecture GPIO Pin Mapping and Conflicts
Peripheral
	Function
	Designated GPIO
	Default ESP32-CAM Function
	Conflict Resolution Status
	Push Button (Input)
	User Trigger
	GPIO 4
	Flash LED / SD_D1
	Disabled LED in firmware; SD component removed.
	I2S Audio RX (INMP441)
	DIN (Data In)
	GPIO 13
	SD_D3
	Freed by SD disable.
	I2S Audio RX/TX
	BCLK (Clock)
	GPIO 14
	SD_CLK
	Freed by SD disable. Shared by I2S0/I2S1.
	I2S Audio RX/TX
	WS (Word Select)
	GPIO 15
	SD_CMD
	Freed by SD disable. Shared by I2S0/I2S1.
	I2S Audio TX (MAX98357A)
	DOUT (Data Out)
	GPIO 5
	Free/Bootstrap/Debug
	Designated TX Data.
	Status LED
	System Status
	GPIO 2
	SD_D0 / Flash/Boot Mode
	Freed by SD disable. Used for debugging/status indication.
	

II. Resource Management and Performance Constraints


Successful operation of this complex, multi-modal system hinges on effective memory management and task distribution, primarily concerning the use of External RAM (PSRAM).


A. PSRAM Availability and Essential Configuration Requirements


The processing requirements for simultaneous camera capture (handling hundreds of kilobytes per frame) and high-sample-rate audio buffering (e.g., 16kHz/16-bit required for effective STT processing) far exceed the internal Static RAM (SRAM) capacity of the ESP32.13 Therefore, the feasibility of the HotPin architecture is absolutely contingent upon the use of an ESP32 variant equipped with PSRAM, such as the ESP32-WROVER-E (typically providing 4MB).13 Standard AI-Thinker modules often lack this external memory.16 The build configuration must explicitly assume and enable PSRAM support.


B. PSRAM Allocation Strategy for High-Bandwidth Buffers


When external RAM (PSRAM) is integrated into the ESP32 memory map during startup 17, applications must explicitly utilize it for large, high-speed buffers. Critical components that must reside in PSRAM include:
1. Camera Frame Buffers: The data structures utilized by the esp_camera driver to store captured OV2640 images must be allocated using memory capabilities that specify external RAM (MALLOC_CAP_SPIRAM).
2. Audio Ring Buffers: The I2S DMA buffers, responsible for continuous audio data streaming from the INMP441 and to the MAX98357A, must be allocated using flags such as MALLOC_CAP_DMA | MALLOC_CAP_SPIRAM.17 This ensures that the buffers are physically located in external RAM but are accessible by the DMA controller, minimizing CPU overhead.18 Large audio accumulation buffers required for STT pre-processing (which may buffer several seconds of high-fidelity audio) must also reside here.14
Managing PSRAM access requires stringent discipline. Since external memory communication relies on the SPI bus, which is inherently slower and subject to timing variability compared to internal SRAM, care must be taken to maintain system stability. When running high-speed peripherals like I2S and the camera, especially when combined with Wi-Fi operations (which can suspend CPU execution to write to flash 19), placing buffers correctly in PSRAM that is DMA-capable is paramount. Furthermore, I2S API calls rely on mutex locks to ensure thread safety.3 Violations of memory access rules or improper synchronization can result in critical errors, such as LoadProhibited exceptions, which compromise the entire system integrity.


C. CPU Utilization Budgeting and Task Prioritization


To manage the concurrent high-demand tasks, the dual-core architecture of the ESP32 must be leveraged through FreeRTOS task affinity and prioritization.
* Core 0 (Pro CPU): This core must be dedicated to high-priority, time-sensitive I/O operations. This includes the I2S DMA Interrupt Service Routines (ISRs), the Wi-Fi/TCP/IP stack, and the low-level WebSocket I/O handler. The core’s mission is to move data efficiently.
* Core 1 (App CPU): This core handles higher-level application logic and heavy processing. Tasks here include camera frame capture logic, STT pre-processing (analysis of buffered audio), WAV header parsing and TTS decoding, and the System State Manager.
I2S data stream tasks (RX and TX) must be assigned high priority (e.g., Priority 9 or 10) and pinned to Core 0 to minimize latency and guarantee audio continuity, preventing buffer underflow or overflow.14


III. Core Peripheral Control: I2S Multiplexing and Switching Mechanism


The central technical challenge is dynamically reconfiguring the I2S peripheral hardware block between two fundamentally different modes of operation: the parallel camera interface and the serial audio interface.


A. Understanding Camera-I2S Mode vs. Standard Audio-I2S Mode


The OV2640 camera interface operates by transferring 8-bit parallel data, synchronized by signals like VSYNC and PCLK, which is handled by the ESP32's I2S peripheral configured in its specialized LCD/Camera mode.1 Standard audio, conversely, uses the I2S block in a serial mode for both transmission and reception.3 These two modes utilize the same underlying hardware registers and DMA channels in conflicting ways, making concurrent operation impossible. Therefore, transitioning between Camera Mode and Voice Interaction Mode requires a complete, controlled teardown and reconstruction of the peripheral drivers.


B. Full-Duplex Audio Implementation


For the Voice Interaction Mode, stability and performance are achieved by utilizing both available I2S controllers on the ESP32: I2S0 for transmission (MAX98357A) and I2S1 for reception (INMP441). Although they use separate data lines (GPIO 5 and GPIO 13, respectively), they share the same clock signals (BCLK on GPIO 14 and WS on GPIO 15). The ESP32 documentation confirms that combining two controllers with shared, identical clock configurations allows for robust full-duplex communication.3


C. State Transition Protocol for Mode Switching


Mode switching must be managed by a dedicated System State Manager task, utilizing synchronization primitives to ensure the driver transitions are atomic and conflict-free. This requires a specific protocol to safely suspend tasks and dismantle hardware drivers before installing new ones.
The procedure to switch from one peripheral configuration to another necessitates the suspension of all associated tasks, followed by the acquisition of a global I2S configuration mutex.3 This mutex prevents any other system task (like background Wi-Fi jobs) from accessing or modifying I2S register settings during the transition.
The most critical step in this protocol is the deinitialization and uninstallation sequence. When moving from Camera to Voice Mode, the Camera Capture Task must be suspended, the mutex acquired, and then the camera driver must be de-initialized (esp_camera_deinit()). This must be followed by calling i2s_driver_uninstall() or an equivalent function if the camera component abstracts the underlying I2S peripheral.20 This action is essential to ensure that the hardware registers and DMA channels used by the camera's parallel mode are fully released and reset. Attempts to install the serial audio I2S driver without a clean prior deinstallation will likely result in a LoadProhibited exception, as the new driver configuration conflicts with residual register settings from the camera mode.22
Once the camera hardware is demonstrably free, the audio drivers (I2S_NUM_0 for TX and I2S_NUM_1 for RX) are installed with their respective configurations and pin assignments. Only then is the I2S configuration mutex released, and the relevant audio stream processing tasks are resumed. The reverse process (Voice Interaction back to Camera) follows the same principle: suspend audio tasks, acquire mutex, uninstall audio drivers, initialize camera driver (esp_camera_init), release mutex, and resume camera capture.
Table 2 details the mandated state transition sequence.
Table 2: State Transition Protocol for I2S/Camera Switching
Current Mode
	Event Trigger
	Action Sequence
	New Mode
	Required Synchronization
	Camera/Standby
	Button Single Click (STT Request)
	1. Suspend Camera Capture Task; 2. Acquire I2S Mutex; 3. De-init Camera Driver; 4. Install I2S Audio Drivers (I2S0 TX, I2S1 RX); 5. Release I2S Mutex; 6. Resume STT/Audio Tasks.
	Voice Interaction (STT Active)
	Global Mutex, Task Suspension
	Voice Interaction
	STT Complete / Timeout
	1. Suspend STT/Audio Tasks; 2. Acquire I2S Mutex; 3. Uninstall I2S Audio Drivers (i2s_driver_uninstall); 4. Init Camera Driver (esp_camera_init); 5. Release I2S Mutex; 6. Resume Camera Capture Task.
	Camera/Standby
	Global Mutex, Task Suspension
	Any Mode
	Button Long Press
	1. Gracefully close WebSockets; 2. Stop all I2S/Camera peripherals; 3. System Halt/Deep Sleep Preparation.
	Shutdown
	Task Notifications, Resource Cleanup
	

IV. Firmware Architecture: Task Management and Event Handling


A robust FreeRTOS structure is necessary to manage data flow and peripheral control.


A. FreeRTOS Task Prioritization Scheme


A stable architecture must adhere to a strict task priority hierarchy:
* Priority 10 (Core 1): System State Manager. Responsible for coordinating mode switching, synchronization, and driver management.
* Priority 9 (Core 0): I2S Audio RX and TX Tasks. Real-time DMA transfer tasks must have maximum priority to guarantee continuous data flow and prevent audio jitter.14
* Priority 8 (Core 0): WebSocket Network I/O Task. Managing the TCP/IP stack and ensuring rapid streaming of audio data (STT) and reception of TTS data. Must run above processing tasks to avoid network buffer backlog.
* Priority 7 (Core 1): STT Processing Task. Handles buffering, pre-processing, and packaging audio chunks for the remote Vosk server.
* Priority 6 (Core 1): Camera Capture Task. Manages frame acquisition, compression, and video streaming.
* Priority 5 (Core 0): Button FSM Dispatcher Task. Processes debounced button events posted from the ISR.
* Priority 5 (Core 1): TTS Decoding/Parser Task. Handles the incoming WAV stream, performs header parsing, and buffers PCM data for the I2S TX task.


B. Inter-Task Communication (Queues and Ring Buffers)


High-volume data streams necessitate the use of efficient buffering mechanisms, primarily allocating ring buffers in PSRAM. The audio data pipeline for STT flows from the I2S RX Task  large PSRAM Ring Buffer  STT Processing Task  WebSocket Task. For TTS playback, the data path is WebSocket Task  TTS Decoding/Parser Task  I2S Audio TX Queue (a smaller DMA queue)  I2S TX Task.


C. Push Button Finite State Machine (FSM) Implementation


The push button on GPIO 4 requires sophisticated handling to differentiate between a single click (mode toggle) and a long press (shutdown). The recommended implementation uses the standard ESP-IDF button component or a custom FSM implementation utilizing FreeRTOS elements.7
The process begins at the Interrupt Service Routine (ISR) layer, where GPIO 4 triggers an interrupt on edge changes (RISING/FALLING). The ISR, which must be IRAM-safe, quickly records a timestamp and posts a minimal event to a FreeRTOS Queue.23
The Button FSM Dispatcher Task (Priority 5, Core 0) consumes these events. It manages software timers to implement debounce logic (typically 20-100ms) and temporal constraints, such as the maximum double-click gap (e.g., 250ms).24 It is crucial that the detection of a single click is deferred until the double-click window has fully expired. If the single-click response were handled immediately upon button-up, a subsequent press within the double-click window would be misinterpreted or missed. By managing these temporal dependencies using a state machine 25, the system ensures that the final event (Single Click or Long Press) accurately reflects the user’s intent before signaling the System State Manager. The single click event maps to the I2S/Camera mode toggle, while a long press (e.g., exceeding 3000ms) maps to system shutdown initiation.


D. Audio Processing Pipeline (WAV Parsing for TTS Playback)


The TTS response, transmitted via WebSocket, is delivered as WAV data. The system must process this stream efficiently for playback.
The TTS Decoding Task first reads the initial 44 bytes of the incoming data stream, which constitutes the RIFF header. This header contains essential metadata: SampleRate, NumChannels, and BitsPerSample.26 This information is crucial for confirming that the currently installed I2S TX driver configuration matches the audio data. If a discrepancy exists (e.g., a sample rate change), the I2S TX driver might need rapid, synchronized reconfiguration before playback commences. Once the header is parsed, the task streams the remaining raw PCM data directly into the I2S TX DMA buffers for output via the MAX98357A. Using specialized audio components in ESP-IDF can abstract much of the chunk parsing and data aggregation, simplifying the pipeline.28


V. Synthesis: Comprehensive AI Codebase Blueprint


The following blueprint contains the explicit architectural and configuration mandates necessary for the AI agent to develop the full ESP-IDF C codebase for the HotPin system.


A. Required ESP-IDF menuconfig Settings


The AI agent must be directed to configure the sdkconfig file with the following settings, which are critical for hardware feasibility and resource management:
1. System Settings:
   * Target Chip: CONFIG_ESP32_DEFAULT_CPU_FREQ_240 (Enabled for performance).
   * Brownout Detector: Disabled (WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); in C code, or configuration).
   * Serial Logger: Enabled on UART0 (GPIO 1/3) at 115200 bps.
2. PSRAM Configuration (Mandatory):
   * External RAM support: CONFIG_ESP32_SPIRAM_SUPPORT=y.
   * Allow DMA access to PSRAM: CONFIG_SPIRAM_ALLOW_DMA=y.
   * FreeRTOS: Configure heap allocation to prefer PSRAM for large blocks.
3. Peripheral Drivers:
   * I2S Component: Enabled, configuring both I2S0 and I2S1.
   * Camera Component: Enabled, using standard AI-Thinker/OV2640 pin definitions.
   * SD/MMC Component: DISABLED (CONFIG_ENABLE_SDMMC_HOST=n). This step is non-negotiable for pin conflict resolution.


B. Hardware Definition Configuration Header


The AI agent must define and use the following C macros for all GPIO pin assignments to ensure the validated architecture (Table 1) is implemented correctly, providing configurability and traceability.
Table 3: Final Configuration Pin Definitions for AI Agent
Component
	Configuration Constant
	Pin Assignment (GPIO_NUM_X)
	Purpose
	I2S TX (MAX98357A)
	CONFIG_I2S_TX_DATA_OUT
	GPIO_NUM_5
	Serial Data Output
	I2S RX (INMP441)
	CONFIG_I2S_RX_DATA_IN
	GPIO_NUM_13
	Serial Data Input
	I2S Shared Clock
	CONFIG_I2S_BCLK
	GPIO_NUM_14
	Bit Clock (Shared by TX/RX)
	I2S Shared Clock
	CONFIG_I2S_LRCK
	GPIO_NUM_15
	Word Select/LRCK (Shared by TX/RX)
	User Input
	CONFIG_PUSH_BUTTON_GPIO
	GPIO_NUM_4
	Mode Switch/Shutdown FSM Trigger
	Status LED
	CONFIG_STATUS_LED_GPIO
	GPIO_NUM_2
	System Status Indicator
	Camera PWDN
	CONFIG_CAMERA_PIN_PWDN
	GPIO_NUM_32
	Camera Power Down
	Camera RESET
	CONFIG_CAMERA_PIN_RESET
	GPIO_NUM_12
	Camera Reset
	Camera XCLK
	CONFIG_CAMERA_PIN_XCLK
	GPIO_NUM_0
	20 MHz Clock
	Camera SCCB SDA
	CONFIG_CAMERA_PIN_SIOD
	GPIO_NUM_26
	I2C Data (SCCB)
	Camera SCCB SCL
	CONFIG_CAMERA_PIN_SIOC
	GPIO_NUM_27
	I2C Clock (SCCB)
	Camera D0-D7
	CONFIG_CAMERA_PIN_D0 to D7
	19, 36, 18, 39, 34, 35, 32, 33
	Parallel Data Bus (Standard AI-Thinker)
	

C. Architectural Pseudocode and Initialization Flow


The AI agent must structure the application around a strict initialization and state management sequence to guarantee hardware stability.


1. System Initialization (app_main):


* Disable Brownout Detector.
* Initialize NVS and Wi-Fi stack.
* Early GPIO Control (Critical): Configure GPIO 4 (CONFIG_PUSH_BUTTON_GPIO) as an output, set it LOW, and call rtc_gpio_hold_en(GPIO_NUM_4) to disable the flash LED and stabilize the pin state before subsequent peripheral initialization.
* Initialize the I2S Configuration Mutex (xSemaphoreCreateMutex).
* Initialize Button FSM component, attaching the ISR to GPIO 4 (e.g., using gpio_install_isr_service and gpio_isr_handler_add).
* Create and start the System State Manager Task (Priority 10, Core 1).
* Start the WebSocket Network I/O Task (Priority 8, Core 0).


2. Initial State Activation (Camera/Standby Mode):


* The State Manager calls a function, camera_init_mode().
* camera_init_mode() acquires the I2S Mutex.
* It then calls esp_camera_init() using the pin configurations defined in Table 3.
* The Camera Capture Task (Priority 6, Core 1) is resumed. The AI agent must ensure camera frame buffers are allocated using MALLOC_CAP_SPIRAM.
* Release the I2S Mutex.


3. Voice Interaction Mode Transition Block (Triggered by Button FSM):


* State Manager receives a "Single Click" event.
* Suspend the Camera Task (vTaskSuspend).
* Acquire the I2S Mutex.
* Call the requisite camera cleanup: esp_camera_deinit().
* Install I2S Audio Drivers for full-duplex operation:
   * i2s_driver_install(I2S_NUM_0, &i2s_tx_config,...) and i2s_set_pin(I2S_NUM_0, &i2s_tx_pin_config).
   * i2s_driver_install(I2S_NUM_1, &i2s_rx_config,...) and i2s_set_pin(I2S_NUM_1, &i2s_rx_pin_config).
   * Mandate: Both I2S configurations must specify DMA buffers allocated using MALLOC_CAP_DMA | MALLOC_CAP_SPIRAM.
* Release the I2S Mutex.
* Resume the I2S RX/TX Tasks and the STT Processing Task.


D. Detailed Step-by-Step Build and Deployment Guide


The following build guide confirms the necessary environment setup and architectural assumptions:
1. Environment Setup: Ensure ESP-IDF (version 4.4 or 5.x recommended) is installed and the build environment is sourced.
2. Configuration Check: Navigate to the project directory and run idf.py menuconfig.
3. Validate Critical Settings:
   * Under Component config -> ESP PSRAM, confirm external RAM is enabled and DMA access is permitted.
   * Under Component config -> Camera, verify the pin definitions match the AI-Thinker standard (corresponding to Table 3).
   * Crucially, confirm that the SD/MMC component is definitively disabled to free the required GPIOs.
4. Build and Flash: Execute idf.py build followed by idf.py flash.
5. Initial System Test: Upon boot, monitor the Serial output. The camera should initialize without memory allocation errors (confirming PSRAM use), and the system Status LED (GPIO 2) should activate to signal successful entry into Camera/Standby Mode. Verify that the Flash LED (GPIO 4) remains off.
6. Functional Test: Initiate a Single Click on the GPIO 4 button. The system must transition immediately, suspending the video stream. Audio drivers should install successfully (validated by the I2S Mutex protocol), and the STT audio streaming pipeline should begin operation. A second Single Click should successfully execute the complex driver uninstallation and re-initialization sequence to return to Camera Mode, validating the I2S multiplexing mechanism.


Conclusions


The HotPin architecture, integrating high-speed vision and full-duplex voice interaction on the constrained ESP32-CAM AI-Thinker platform, is feasible but strictly dependent on key structural decisions. The analysis confirms three critical prerequisites: (1) mandatory physical PSRAM (ESP32-WROVER-E equivalent) and corresponding MALLOC_CAP_SPIRAM | MALLOC_CAP_DMA allocation for all high-volume buffers; (2) the complete disabling of the internal SD card interface to free necessary GPIOs (13, 14, 15, 5, 4, 2); and (3) the implementation of a rigorous, mutex-protected State Transition Protocol involving atomic driver uninstallation (i2s_driver_uninstall) to safely switch the shared I2S peripheral between Camera Parallel Mode and Audio Serial Mode.
The validated pinout and FreeRTOS task prioritization scheme, which reserves Core 0 for real-time I/O tasks (I2S DMA and Network) and Core 1 for processing, provides the necessary architectural stability. Furthermore, explicit control over GPIO 4, setting it low and using rtc_gpio_hold_en, is necessary to manage hardware artifacts like the "ghost flash" effect and ensure reliable button input detection. The successful deployment relies entirely on the AI agent precisely implementing these architectural constraints and using the specified GPIO assignments defined in Table 3.
Works cited
1. I2S - ESP32 - — ESP-IDF Programming Guide release-v4.2 documentation, accessed on October 6, 2025, https://docs.espressif.com/projects/esp-idf/en/release-v4.2/esp32/api-reference/peripherals/i2s.html
2. Sound with ESP32 - I2S Protocol - DroneBot Workshop, accessed on October 6, 2025, https://dronebotworkshop.com/esp32-i2s/
3. Inter-IC Sound (I2S) - ESP32 - — ESP-IDF Programming Guide v5.5.1 documentation, accessed on October 6, 2025, https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/peripherals/i2s.html
4. Inter-IC Sound (I2S) - ESP32-S2 - — ESP-IDF Programming Guide v5.5.1 documentation, accessed on October 6, 2025, https://docs.espressif.com/projects/esp-idf/en/stable/esp32s2/api-reference/peripherals/i2s.html
5. ESP32-CAM AI-Thinker Pinout Guide: GPIOs Usage Explained - Random Nerd Tutorials, accessed on October 6, 2025, https://randomnerdtutorials.com/esp32-cam-ai-thinker-pinout/
6. ESP32 CAM — SunFounder GalaxyRVR Kit for Arduino 1.0 documentation, accessed on October 6, 2025, https://docs.sunfounder.com/projects/galaxy-rvr/en/latest/hardware/cpn_esp_32_cam.html
7. Button Driver for Tactile Switches Buttons Compatible with ESP-IDF and STM32CubeIDE - GitHub, accessed on October 6, 2025, https://github.com/mauriciobarroso/button
8. Button - - — ESP-IoT-Solution release-v2.0 documentation - Espressif Systems, accessed on October 6, 2025, https://docs.espressif.com/projects/esp-iot-solution/en/release-v2.0/input_device/button.html
9. how to disable flash light on thinker esp32-cam - DroneBot Workshop Forums, accessed on October 6, 2025, https://forum.dronebotworkshop.com/project-help/how-to-disable-flash-light-on-thinker-esp32-cam/
10. Control ESP32-CAM Flash LED - Makerguides.com, accessed on October 6, 2025, https://www.makerguides.com/control-esp32-cam-flash-led/
11. How do I prevent esp32 cam from flashing when it takes a photo? - Reddit, accessed on October 6, 2025, https://www.reddit.com/r/esp32/comments/1jyh9xq/how_do_i_prevent_esp32_cam_from_flashing_when_it/
12. Available GPIO on ESP32 Cam - RNT Lab, accessed on October 6, 2025, https://rntlab.com/question/available-gpio-on-esp32-cam/
13. [EOL] PSRAM Camera Module with ESP32 WROVER (OV2640) - m5stack-store, accessed on October 6, 2025, https://shop.m5stack.com/products/esp-32-camera-psram
14. Can ESP32 Handle Complex Audio Streaming Project? - Reddit, accessed on October 6, 2025, https://www.reddit.com/r/esp32/comments/1ax7mep/can_esp32_handle_complex_audio_streaming_project/
15. Getting Started with the Freenove ESP32-Wrover CAM Board - Random Nerd Tutorials, accessed on October 6, 2025, https://randomnerdtutorials.com/getting-started-freenove-esp32-wrover-cam/
16. I have a faulty PSRAM on my ESP32-CAM... What should I do with it? - Reddit, accessed on October 6, 2025, https://www.reddit.com/r/esp32/comments/z2hyns/i_have_a_faulty_psram_on_my_esp32cam_what_should/
17. Support for External RAM - ESP32 - — ESP-IDF Programming Guide v5.5.1 documentation, accessed on October 6, 2025, https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/external-ram.html
18. Broadcasting Your Voice with ESP32-S3 & INMP441 - YouTube, accessed on October 6, 2025, https://www.youtube.com/watch?v=qq2FRv0lCPw
19. Speed Optimization - ESP32 - — ESP-IDF Programming Guide v5.5.1 documentation, accessed on October 6, 2025, https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/performance/speed.html
20. I2S - - — ESP-IDF Programming Guide v4.1.2 documentation, accessed on October 6, 2025, https://docs.espressif.com/projects/esp-idf/en/v4.1.2/api-reference/peripherals/i2s.html
21. I2S - ESP32-S2 - — ESP-IDF Programming Guide v4.3 documentation - Espressif Systems, accessed on October 6, 2025, https://docs.espressif.com/projects/esp-idf/en/v4.3/esp32s2/api-reference/peripherals/i2s.html
22. GPIO conflicts with I2S interrupt - ESP32 Forum, accessed on October 6, 2025, https://esp32.com/viewtopic.php?t=1665
23. ESP32 Tutorial: Debouncing a Button Press using Interrupts - SwitchDoc Labs Blog, accessed on October 6, 2025, https://www.switchdoc.com/2018/04/esp32-tutorial-debouncing-a-button-press-using-interrupts/
24. Implementing a single press, long press and a double press function in HAL for STM32, accessed on October 6, 2025, https://stackoverflow.com/questions/66823397/implementing-a-single-press-long-press-and-a-double-press-function-in-hal-for-s
25. single iot-button with a range of long-hold intervals for different modes - ESP32 Forum, accessed on October 6, 2025, https://esp32.com/viewtopic.php?t=38331
26. Decoding a WAV File Header - hex - Stack Overflow, accessed on October 6, 2025, https://stackoverflow.com/questions/29992898/decoding-a-wav-file-header
27. How to Parse Wav File | Hasan Hasanov's Blog, accessed on October 6, 2025, https://hasan-hasanov.com/post/2023/10/how_to_parse_wav_file/
28. espressif/esp_audio_codec • v2.3.0 - ESP Component Registry, accessed on October 6, 2025, https://components.espressif.com/components/espressif/esp_audio_codec
29. Audio Streams - - — Espressif Advanced Development Framework Guide latest documentation, accessed on October 6, 2025, https://docs.espressif.com/projects/esp-adf/en/latest/api-reference/streams/index.html